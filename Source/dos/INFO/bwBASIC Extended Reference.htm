<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0036)http://www.bwbasic.com/extended.html -->
<HTML><HEAD><TITLE>bwBASIC Extended Reference</TITLE>
<META content="text/html; charset=iso-8859-1" http-equiv=Content-Type>
<META content="MSHTML 5.00.3019.2500" name=GENERATOR>
<META 
content="BASIC, bwBASIC, scripting, scripts, CGI, language, languages, Bywater" 
name=keywords>
<META content=all,index,follow name=robots></HEAD>
<BODY bgColor=#c0c0c0 text=#800000>
<DIV align=center>
<CENTER>
<TABLE border=0 width="100%">
  <TBODY>
  <TR>
    <TD align=middle bgColor=#800000>
      <H2 align=center><FONT color=#ffffff>Bywater BASIC Extended Reference 
      Guide</FONT></H2></TD></TR>
  <TR>
    <TD>
      <HR>
    </TD></TR></TBODY></TABLE></CENTER></DIV>
<P>&nbsp;</P>
<TABLE border=0 borderColorDark=#800000 cellPadding=2 width="100%">
  <TBODY>
  <TR>
    <TH align=left bgColor=#8080ff vAlign=top>
      <P align=center><STRONG>Command or Function</STRONG></P></TH>
    <TH align=left bgColor=#8080ff vAlign=top>
      <P align=center><STRONG>Description</STRONG></P></TH>
    <TH align=left bgColor=#8080ff vAlign=top>
      <P align=center><STRONG>Dependencies</STRONG></P></TH></TR>
  <TR>
    <TD vAlign=top>Function: <B>ABS( number ) </B></TD>
    <TD vAlign=top>ABS returns the absolute value of the argument 'number'. 
</TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>ASC( string$ ) </B></TD>
    <TD vAlign=top>ASC returns the ASCII code for the first letter in the 
      argument string$. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>ATN( number ) </B></TD>
    <TD vAlign=top>ATN returns the arctangent value of the argument 'number' 
      in radians. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CALL subroutine-name </B></TD>
    <TD vAlign=top>CALL calls a named subroutine (see SUB and END SUB). </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CASE ELSE | IF partial-expression | constant 
      </B></TD>
    <TD vAlign=top>CASE introduces an element of a SELECT CASE statement (see 
      SELECT CASE). CASE IF introduces a conditional SELECT CASE element, and 
      CASE ELSE introduces a default SELECT CASE element. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CHAIN [MERGE] file-name [, line-number] [, ALL] 
      </B></TD>
    <TD vAlign=top>CHAIN passes control to another BASIC program. Variables 
      declared COMMON (q.v.) will be passed to the new program. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CHDIR pathname$ </B></TD>
    <TD vAlign=top>CHDIR changes the current directory to that indicated by 
      the argument pathname$. </TD>
    <TD vAlign=top>UNIX_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>CHR$( number ) </B></TD>
    <TD vAlign=top>CHR$ returns a one-character string with the character 
      corresponding to the ASCII code indicated by argument 'number'. </TD>
    <TD vAlign=top>COMMON_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>CINT( number ) </B></TD>
    <TD vAlign=top>CINT returns the truncated integer for the argument 
      'number'. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CLEAR </B></TD>
    <TD vAlign=top>CLEAR sets all numerical variables to 0, and all string 
      variables to null. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CLOSE [[#]file-number]... </B></TD>
    <TD vAlign=top>CLOSE closes the file indicated by file-number (see OPEN). 
    </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CLS </B></TD>
    <TD vAlign=top>CLS clears the display screen (IBM and compatibles only as 
      of version 2.10). </TD>
    <TD vAlign=top>IMP_IQC and IMP_CMDLOC </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>CMDS </B></TD>
    <TD vAlign=top>CMDS is a debugging command that prints a list of all 
      implemented bwBASIC commands. </TD>
    <TD vAlign=top>DEBUG </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>COMMON variable [, variable...] </B></TD>
    <TD vAlign=top>COMMON designates variables to be passed to a CHAINed 
      program (see CHAIN). </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>COS( number ) </B></TD>
    <TD vAlign=top>COS returns the cosine of the argument 'number' in radians. 
    </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>CSNG( number ) </B></TD>
    <TD vAlign=top>CSNG is a pseudo-function that has no effect under bwBASIC. 
      It replicates a Microsoft-type command that would convert the 'number' to 
      single-precision. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>CVD( string$ ) </B></TD>
    <TD vAlign=top>CVD converts the argument string$ into a bwBASIC number 
      (precision is irrelevant in bwBASIC since bwBASIC numbers have only one 
      precision). Implenentation-Specific Notes: CVD(), CVI(), CVS(), MKI$(), 
      MKD$(), MKS$(): These functions are implemented, but are dependent on a) 
      the sizes for integer, float, and double values on particular systems, and 
      b) how particular versions of C store these numerical values. The 
      implication is that data files created using these functions on a 
      DOS-based microcomputer may not be translated correctly by bwBASIC running 
      on a Unix-based computer. Similarly, data files created by bwBASIC 
      compiled by one version of C may not be readable by bwBASIC compiled by 
      another version of C (even under the same operating system). So be careful 
      with these. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>CVI( string$ ) </B></TD>
    <TD vAlign=top>CVI converts the argument string$ into a bwBASIC number 
      (precision is irrelevant in bwBASIC since bwBASIC numbers have only one 
      precision; see also the note on CVD). </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>CVS( string$ ) </B></TD>
    <TD vAlign=top>CVI converts the argument string$ into a bwBASIC number 
      (precision is irrelevant in bwBASIC since bwBASIC numbers have only one 
      precision; see also the note on CVD). </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DATA constant[,constant]... </B></TD>
    <TD vAlign=top>DATA stores numerical and string constants to be accessed 
      by READ (q.v.). </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>DATE$ </B></TD>
    <TD vAlign=top>DATE$ returns the current date based on the computer's 
      internal clock as a string in the form "YYYY-MM-DD". As implemented under 
      bwBASIC, DATE$ cannot be used for assignment (i.e., to set the system 
      date). Note: bwBASIC presently (v2.10) does not allow assignment to a 
      function. </TD>
    <TD vAlign=top>COMMON_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DEF FNname(arg...)] = expression </B></TD>
    <TD vAlign=top>DEF defines a user-written function. This function 
      corresponds to Microsoft-type implementation, although in bwBASIC DEF is a 
      working equivalent of FUNCTION. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DEFDBL letter[-letter](, letter[-letter])... 
      </B></TD>
    <TD vAlign=top>DEFDBL declares variables with single-letter names as 
      numerical variables (precision is irrelevant in bwBASIC). </TD>
    <TD vAlign=top>MS_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DEFINT letter[-letter](, letter[-letter])... 
      </B></TD>
    <TD vAlign=top>DEFINT declares variables with single-letter names as 
      numerical variables (precision is irrelevant in bwBASIC). </TD>
    <TD vAlign=top>MS_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DEFSNG letter[-letter](, letter[-letter])... 
      </B></TD>
    <TD vAlign=top>DEFSNG declares variables with single-letter names as 
      numerical variables (precision is irrelevant in bwBASIC). </TD>
    <TD vAlign=top>MS_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DEFSTR letter[-letter](, letter[-letter])... 
      </B></TD>
    <TD vAlign=top>DEFSTR declares variables with single-letter names as 
      string variables. </TD>
    <TD vAlign=top>MS_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DELETE line[-line] </B></TD>
    <TD vAlign=top>DELETE deletes program lines indicated by the argument(s). 
      If you want to use DELETE for non- numbered programs, first use DO NUM, 
      then DELETE, then DO UNNUM. </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DIM 
      variable(elements...)[variable(elements...)]... </B></TD>
    <TD vAlign=top>DIM specifies variables that have more than one element in 
      a single dimension, i.e., arrayed variables. Note: As implemented under 
      bwBASIC, DIM accepts only parentheses as delimiters for variable fields. 
      (Some BASICs allow the use of square brackets.) </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DO NUM|UNNUM </B></TD>
    <TD vAlign=top>DO NUM numbers all lines in a program. The first line is 
      given the number 10, and subsequent lines are numbered consecutively in 
      multiples of 10. DO UNNUM removes all line numbers from a program. NOTE 
      that these functions do nothing to line numbers, e.g., following a GOSUB 
      or GOTO statement; these commands cannot be used as a replacement for 
      RENUM (available in some systems, but not bwBASIC). With these commands, 
      however, one can develop unnumbered programs by entering new lines with 
      numbers, then running DO UNNUM to remove the line numbers. Together with 
      LOAD and SAVE (q.v.) one can use bwBASIC as a primitive text editor. </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>DO [WHILE expression] </B></TD>
    <TD vAlign=top>DO implements a number of forms of program loops. DO...LOOP 
      simply loops; the only way out is by EXIT; DO WHILE...LOOP loops while 
      "expression" is true (this is equivalent to the older WHILE-WEND loop, 
      also implemented in bwBASIC); DO...LOOP UNTIL loops until the expression 
      following UNTIL is true. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>EDIT </B></TD>
    <TD vAlign=top>EDIT is a pseudo-command which calls the text editor 
      specified in the variable BWB.EDITOR$ to edit the program in memory. After 
      the call to the text editor, the (edited) prgram is reloaded into memory. 
      The user normally must specific a valid path and filename in BWB.EDITOR$ 
      before this command will be useful. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>ELSE </B></TD>
    <TD vAlign=top>ELSE introduces a default condition in a multi-line IF 
      statement. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>ELSEIF </B></TD>
    <TD vAlign=top>ELSEIF introduces a secondary condition in a multi- line IF 
      statement. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>END IF | FUNCTION | SELECT | SUB </B></TD>
    <TD vAlign=top>END IF ends a multi-line IF statement. END FUNCTION ends a 
      multi-line function definition. END SELECT ends a SELECT CASE statement. 
      END SUB ends a multi- line subroutine definition. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>ENVIRON variable-string$ = string$ </B></TD>
    <TD vAlign=top>ENVIRON sets the environment variable identified by 
      variable-string$ to string$. It might be noted that this differs from the 
      implementation of ENVIRON in some versions of BASIC, but bwBASIC's ENVIRON 
      allows BASIC variables to be used on either side of the equals sign. Note 
      that the function ENVIRON$() is different from the command, and be aware 
      of the fact that in some operating systems an environment variable set 
      within a program will not be passed to its parent shell. </TD>
    <TD vAlign=top>UNIX_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>ENVIRON$( variable-string$ ) </B></TD>
    <TD vAlign=top>ENVIRON$ returns the environment variable associated with 
      the name variable-string$. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>EOF( device-number ) </B></TD>
    <TD vAlign=top>EOF returns TRUE (-1) if the device associated with 
      device-number is at the end-of-file, otherwise it returns FALSE (0). </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>ERASE variable[, variable]... </B></TD>
    <TD vAlign=top>ERASE eliminates arrayed variables from a program. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>ERL </B></TD>
    <TD vAlign=top>ERL returns the line number of the most recent error. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>ERR </B></TD>
    <TD vAlign=top>ERR returns the error number of the most recent error. Note 
      that if PROG_ERRORS has been defined when bwBASIC is compiled, the ERR 
      variable will not be set correctly upon errors. It only works when 
      standard error messages are used. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>ERROR number </B></TD>
    <TD vAlign=top>ERROR simulates an error, i.e., displays the message 
      appropriate for that error. This command is helpful in writing ON ERROR 
      GOSUB routines that can identify a few errors for special treatment and 
      then ERROR ERR (i.e., default handling) for all others. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>EXIT [FOR] </B></TD>
    <TD vAlign=top>EXIT by itself exits from a DO...LOOP loop; EXIT FOR exits 
      from a FOR...NEXT loop. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>EXP( number ) </B></TD>
    <TD vAlign=top>EXP returns the exponential value of 'number'. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>FIELD [#] device-number, number AS 
      string-variable$ [, number AS string-variable$...] </B></TD>
    <TD vAlign=top>FIELD allocates space in a random file buffer for device 
      indicated by device-number, allocating 'number' bytes and assigning the 
      bytes at this position to the variable string-variable$. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>FILES filespec$ </B></TD>
    <TD vAlign=top>FILES is a pseudocommand that invokes the directory program 
      specified in the variable BWB.FILES$ with the argument filespec$. 
      Normally, the user must set this variable before FILES can be used. E.g., 
      for PC-type computers, BWB.FILES$ = "DIR" will work, for Unix machines, 
      BWB.FILES$ = "ls -l" etc. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>FNCS </B></TD>
    <TD vAlign=top>CMDS is a debugging command that prints a list of all 
      pre-defined bwBASIC functions. </TD>
    <TD vAlign=top>DEBUG </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>FUNCTION </B></TD>
    <TD vAlign=top>FUNCTION introduces a function definition, normally ending 
      with END FUNCTION. In bwBASIC, FUNCTION and DEF are qorking equivalents, 
      so either can be used with single-line function definitions or with multi- 
      line definitions terminated by END FUNCTION. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>FOR counter = start TO finish [STEP increment] 
      </B></TD>
    <TD vAlign=top>FOR initiates a FOR-NEXT loop with the variable 'counter' 
      initially set to 'start' and incrementing in 'increment' steps (default is 
      1) until 'counter' equals 'finish'. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>GET [#] device-number [, record-number] </B></TD>
    <TD vAlign=top>GET reads the next reacord from a random-access file or 
      device into the buffer associated with that file. If record-number is 
      specified, the GET command reads the specified record. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>GOSUB line | label </B></TD>
    <TD vAlign=top>GOSUB initiates a subroutine call to the line (or label) 
      specified. The subroutine must end with RETURN. </TD>
    <TD vAlign=top>(core), but STRUCT_CMDS for labels </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>GOTO line | label </B></TD>
    <TD vAlign=top>GOTO branches program execution to the specified line (or 
      label). </TD>
    <TD vAlign=top>(core), but STRUCT_CMDS for labels </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>HEX$( number ) </B></TD>
    <TD vAlign=top>HEX$ returns a string giving the hexadecimal (base 16) 
      value for the 'number'. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>IF expression THEN [statement [ELSE statement]] 
      </B></TD>
    <TD vAlign=top>IF evaluates 'expression' and performs the THEN statement 
      if it is true or (optionally) the ELSE statement if it is FALSE. If 
      STRUCT_CMDS is set to TRUE, bwBASIC allows multi-line IF statements with 
      ELSE and ELSEIF cases, ending with END IF. </TD>
    <TD vAlign=top>(core), STRUCT_CMDS for multi-line IF statements </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>INKEY$ </B></TD>
    <TD vAlign=top>INKEY$ reads the status of the keyboard, and a single 
      keypress, if available. If a keypress is not available, then INKEY$ 
      immediately returns a null string (""). Currently (v2.10) implemented in 
      bwx_iqc.c only. </TD>
    <TD vAlign=top>IMP_IQC and IMP_CMDLOC </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>INPUT [# device-number]|[;]["prompt 
      string";]list of variables </B></TD>
    <TD vAlign=top>INPUT allows input from the terminal or a device specified 
      by device-number. If terminal, the "prompt string" is output, and input is 
      assigned to the appropriate variables specified. bwBASIC does not support 
      the optional feature of INPUT that suppresses the carriage-return and 
      line-feed at the end of the input. This is because C alone does not 
      provide for any means of input other than CR-LF-terminated strings. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>INSTR( [start-position,] string-searched$, 
      string-pattern$ ) </B></TD>
    <TD vAlign=top>INSTR returns the position at which string-pattern$ occurs 
      in string-searched$, beginning at start-position. As implemented in 
      bwBASIC, INSTR cannot be used for assignments. Note: bwBASIC presently 
      (v2.10) does not allow assignment to a function. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>INT( number ) </B></TD>
    <TD vAlign=top>INT returns the largest integer less than or equal to the 
      argument 'number'. NOTE that this is not a "truncated" integer function, 
      for which see CINT. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>KILL file-name$ </B></TD>
    <TD vAlign=top>KILL deletes the file specified by file-name$. </TD>
    <TD vAlign=top>UNIX_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>LEFT$( string$, number-of-spaces ) </B></TD>
    <TD vAlign=top>LEFT$ returns a substring a string$ with number-of-spaces 
      from the left (beginning) of the string). As implemented under bwBASIC, it 
      cannot be used for assignment. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>LEN( string$ ) </B></TD>
    <TD vAlign=top>LEN returns the length in bytes of string$. </TD>
    <TD vAlign=top>COMMON_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>LET variable = expression </B></TD>
    <TD vAlign=top>LET assigns the value of 'expression' to the variable. As 
      currently implemented, bwBASIC supports implied LET statements (e.g., "X = 
      4.5678" at the beginning of a line or line segment, but does not support 
      assignment to multiple variables (e.g., "x, y, z = 3.141596"). </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>LINE INPUT [[#] device-number,]["prompt 
      string";] string-variable$ </B></TD>
    <TD vAlign=top>LINE INPUT reads entire line from the keyboard or a file or 
      device into string-variable$. If input is from the keyboard (stdin), then 
      "prompt string" will be printed first. Unlike INPUT, LINE INPUT reads a 
      whole line, not stopping for comma-delimited data items. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>LIST line[-line] </B></TD>
    <TD vAlign=top>LIST lists program lines as specified in its argument. </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>LOAD file-name </B></TD>
    <TD vAlign=top>LOAD loads an ASCII BASIC program into memory. </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>LOC( device-number ) </B></TD>
    <TD vAlign=top>LOC returns the next record that GET or PUT statements will 
      use. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>LOCATE line, column </B></TD>
    <TD vAlign=top>LOCATE addresses trhe curor to a specified line and column. 
      Currently (v2.10) implemented in bwx_iqc.c only. </TD>
    <TD vAlign=top>IMP_IQC and IMP_CMDLOC </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>LOF( device-number ) </B></TD>
    <TD vAlign=top>LOF returns the length of a file (specified by 
      device-number) in bytes. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>LOG( number ) </B></TD>
    <TD vAlign=top>LOG returns the natural logarithm of the argument 'number'. 
    </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>LOOP [UNTIL expression] </B></TD>
    <TD vAlign=top>LOOP terminates a program loop: see DO. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>LSET string-variable$ = expression </B></TD>
    <TD vAlign=top>LSET transfers data from 'expression' to the left-hand side 
      of a string variable or random access buffer field. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>MERGE file-name </B></TD>
    <TD vAlign=top>MERGE adds program lines from 'file-name' to the program in 
      memory. Unlike LOAD, it does not clear the program currently in memory. 
</TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>MID$( string$, start-position-in-string[, 
      number-of-spaces ] ) </B></TD>
    <TD vAlign=top>MID$ returns a substring of string$ beginning at 
      start-position-in-string and continuing for number-of-spaces bytes. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>MKDIR pathname$ </B></TD>
    <TD vAlign=top>MKDIR creates a new directory path as specified by 
      pathname$. </TD>
    <TD vAlign=top>UNIX_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>MKD$( number ) </B></TD>
    <TD vAlign=top>MKD$, MKI$, and MKS$ are all equivalent in bwBASIC. They 
      convert the numerical value 'number' into a string which can be stored in 
      a more compressed form in a file (especially for random file access). 
      Since bwBASIC does not recognize differences in precision, these commands 
      are effectively equivalent. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>MKI$( number ) </B></TD>
    <TD vAlign=top>Equivalent to MKD$ (q.v.) </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>MKS$( number ) </B></TD>
    <TD vAlign=top>Equivalent to MKD$ (q.v.). </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>NAME old-file-name AS new-file-name </B></TD>
    <TD vAlign=top>NAME renames an existing file (old-file-name) as 
      new-file-name. </TD>
    <TD vAlign=top>UNIX_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>NEW </B></TD>
    <TD vAlign=top>NEW deletes the program in memory and clears all variables. 
    </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>NEXT [counter-variable] </B></TD>
    <TD vAlign=top>NEXT comes at the end of a FOR-NEXT loop; see FOR. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>OCT$( number ) </B></TD>
    <TD vAlign=top>OCT$ returns a string giving the octal (base 8) 
      representation of 'number'. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>ON variable GOTO|GOSUB line[,line,line,...] 
    </B></TD>
    <TD vAlign=top>ON either branches (GOTO) or calls a subroutine (GOSUB) 
      based on the rounded value of variable; if it is 1, the first line is 
      called, if 2, the second line is called, etc. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>ON ERROR GOSUB line|label </B></TD>
    <TD vAlign=top>ON ERROR sets up an error handling subroutine. See also 
      ERROR. </TD>
    <TD vAlign=top>COMMON_CMDS, STRUCT_CMDS for labels </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>OPEN "O"|"I"|"R", [#]device-number, file-name 
      [,record length] file-name FOR INPUT|OUTPUT|APPEND AS [#]device-number 
      [LEN = record-length] </B></TD>
    <TD vAlign=top>OPEN allocates random access memory for access to a disk 
      file or other device. Note that two quite different forms of the OPEN 
      statement are supported. In the first form, "O" (note that these letters 
      must be encased in quotation marks) denotes sequential output, "I" denotes 
      sequential input, and "R" denotes random-access input and output. Once 
      OPEN, any number of operations can be performed on a device (see WRITE #, 
      INPUT #, PRINT #, etc.). </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>OPTION BASE number </B></TD>
    <TD vAlign=top>OPTION BASE sets the lowest value for array subscripts, 
      either 0 or 1. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>POS </B></TD>
    <TD vAlign=top>POS returns the current cursor position in the line. </TD>
    <TD vAlign=top>COMMON_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>PRINT [# device-number,][USING format-string$;] 
      expressions... </B></TD>
    <TD vAlign=top>PRINT outputs text to the screen or to a file or device 
      specified by device-number. In the current implementation of bwBASIC, 
      expressions to be printed must be separated by the comma (tabbed output), 
      the semicolon (immediate sequential output) or the plus sign (immediate 
      sequential output by string concatenation). Expressions separated by 
      blanks or tabs are not supported. If USING is specified, a number of 
      formatting marks may appear in the format string: ! prints the first 
      character of a string \\ prints 2+x characters of a string, where x = the 
      number of spaces between the backslashes &amp; variable-length string 
      field # represents a single digit in output format for a number . decimal 
      point in a number + sign of a number (will output + or -) - trailing minus 
      after a number ** fill leading spaces with asterisks $$ output dollar sign 
      in front of a number ^^ output number in exponential format _ output next 
      character literally As currently implemented, the exponential format will 
      be that used by the C compiler. </TD>
    <TD vAlign=top>(core), COMMON_FUNCS for USING </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>PUT [#] device-number [, record-number] </B></TD>
    <TD vAlign=top>PUT outputs the next available record or the record 
      specified by record-number to the file or device denoted by device-number. 
    </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>QUIT </B></TD>
    <TD vAlign=top>QUIT is a synonym for SYSTEM; with INTERACTIVE environment, 
      it exits the program to the operating system (or the calling program). </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>RANDOMIZE number </B></TD>
    <TD vAlign=top>RANDOMIZE seeds the random number generator (see RND). 
      Under bwBASIC, the TIMER function (q.v.) can be used to supply a 'number' 
      seed for the random number generator. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>READ variable[, variable]... </B></TD>
    <TD vAlign=top>READ reads values from DATA statements and assigns these 
      values to the named variables. Variable types in a READ statement must 
      match the data types in DATA statements as they are occurred. See also 
      DATA and RESTORE. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>REM string </B></TD>
    <TD vAlign=top>REM allows remarks to be included in a program. As 
      currently implemented, the entire line following REM is ignored by the 
      interpreter (thus, even if MULTISEG_LINES is set, a REM line will not be 
      able to find a segment delimiter (":") followed by another line segment 
      with command. bwBASIC does not currently implement the Microsoft-style use 
      of the single quotation mark to denote remarks. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>RESTORE line </B></TD>
    <TD vAlign=top>RESTORE resets the line and position counters for DATA and 
      READ statements to the top of the program file or to the beginning of the 
      specified line. (Currently this must be a line number.) </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>RETURN </B></TD>
    <TD vAlign=top>RETURN concludes a subroutine called by GOSUB. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>RIGHT$( string$, number-of-spaces ) </B></TD>
    <TD vAlign=top>RIGHT$ returns a substring a string$ with number-of-spaces 
      from the right (end) of the string). As implemented under bwBASIC, it 
      cannot be used for assignment. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>RMDIR pathname </B></TD>
    <TD vAlign=top>RMDIR deletes the directory path indicated by pathname. </TD>
    <TD vAlign=top>UNIX_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>RND( number ) </B></TD>
    <TD vAlign=top>RND returns a pseudo-random number. The 'number' value is 
      ignored by bwBASIC if supplied. The RANDOMIZE command (q.v.) reseeds the 
      random-number generator. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>RSET string-variable$ = expression </B></TD>
    <TD vAlign=top>RSET transfers data from 'expression' to the right-hand 
      side of a string variable or random access buffer field. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>RUN [line][file-name$] </B></TD>
    <TD vAlign=top>RUN executes the program in memory. If a file-name$ is 
      supplied, then the specified file is loaded into memory and executed. If a 
      line number is supplied, then execution begins at that line. </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>SAVE file-name$ </B></TD>
    <TD vAlign=top>SAVE saves the program in memory to file-name$. bwBASIC 
      only saves files in ASCII format. </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>SELECT CASE expression </B></TD>
    <TD vAlign=top>SELECT CASE introduces a multi-line conditional selection 
      statement. The expression given as the argument to SELECT CASE will be 
      evaluated by CASE statements following. The SELECT CASE statement 
      conclludes with an END SELECT statement. As currently implemented, CASE 
      statements may be followed by string values, but in this case only simple 
      comparisons (equals, not equals) can be performed. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>SGN( number ) </B></TD>
    <TD vAlign=top>SGN returns the sign of the argument 'number', +1 for 
      positive numbers, 0 for 0, and -1 for negative numbers. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>SIN( number ) </B></TD>
    <TD vAlign=top>SIN returns the sine of the argument 'number' in radians. 
    </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>SPACE$( number ) </B></TD>
    <TD vAlign=top>SPACE$ returns a string of blank spaces 'number' bytes 
      long. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>SPC( number ) </B></TD>
    <TD vAlign=top>SPC returns a string of blank spaces 'number' bytes long. 
    </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>SQR( number ) </B></TD>
    <TD vAlign=top>SQR returns the square root of the argument 'number'. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>STOP </B></TD>
    <TD vAlign=top>STOP interrupts program execution. As implemented under 
      bwBASIC, STOP issues a SIGINT signal. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>STR$( number ) </B></TD>
    <TD vAlign=top>STR$ returns a string giving the decimal (base 10) 
      representation of the argument 'number'. </TD>
    <TD vAlign=top>COMMON_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>STRING$( number, ascii-value|string$ ) </B></TD>
    <TD vAlign=top>STRING$ returns a string 'number' bytes long consisting of 
      either the first character of string$ or the character answering to the 
      ASCII value ascii-value. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>SUB subroutine-name </B></TD>
    <TD vAlign=top>SUB introduces a named, multi-line subroutine. The 
      subroutine is called by a CALL statement, and concludes with an END SUB 
      statement. </TD>
    <TD vAlign=top>STRUCT_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>SWAP variable, variable </B></TD>
    <TD vAlign=top>SWAP swaps the values of two variables. The two variables 
      must be of the same type (either numerical or string). </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>SYSTEM </B></TD>
    <TD vAlign=top>SYSTEM exits from bwBASIC to the calling program or (more 
      usually) the operating system. </TD>
    <TD vAlign=top>INTERACTIVE </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>TAB( number ) </B></TD>
    <TD vAlign=top>TAB outputs spaces until the column indicated by 'number' 
      has been reached. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>TAN( number ) </B></TD>
    <TD vAlign=top>TAN returns the tangent of the argument 'number' in 
      radians. </TD>
    <TD vAlign=top>(core) </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>TIME$ </B></TD>
    <TD vAlign=top>TIME$ returns the current time based on the computer's 
      internal clock as a string in the form "HH-MM-SS". As implemented under 
      bwBASIC, TIME$ cannot be used for assignment (i.e., to set the system 
      time). Note: bwBASIC presently (v2.10) does not allow assignment to a 
      function. </TD>
    <TD vAlign=top>COMMON_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>TIMER </B></TD>
    <TD vAlign=top>TIMER returns the time in the system clock in seconds 
      elapsed since midnight. </TD>
    <TD vAlign=top>MS_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>TROFF </B></TD>
    <TD vAlign=top>TROFF turns of the trace facility; see TRON. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>TRON </B></TD>
    <TD vAlign=top>TRON turns on the trace facility. This facility will print 
      each line number in square brackets as the program is executed. This is 
      useful in debugging programs with line numbers. To debug an unnumbered 
      program with TRON, call DO NUM first, but remember to call DO UNNUM before 
      you save the program later. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Function: <B>VAL( string$ ) </B></TD>
    <TD vAlign=top>VAL returns the numerical value of the string$. </TD>
    <TD vAlign=top>COMMON_FUNCS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>VARS </B></TD>
    <TD vAlign=top>VARS is a debugging command which prints a list of all 
      variables defined which have global scope. </TD>
    <TD vAlign=top>DEBUG </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>WEND </B></TD>
    <TD vAlign=top>WEND concludes a WHILE-WEND loop; see WHILE. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>WHILE expression </B></TD>
    <TD vAlign=top>WHILE initiates a WHILE-WEND loop. The loop ends with WEND, 
      and execution reiterates through the loop as long as the 'expression' is 
      TRUE (-1). </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>WIDTH [# device-number,] number </B></TD>
    <TD vAlign=top>WIDTH sets screen or device output to 'number' columns. 
      device-number specifies the device or file for oputput. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR>
  <TR>
    <TD vAlign=top>Command: <B>WRITE [# device-number,] element [, element 
      ].... </B></TD>
    <TD vAlign=top>WRITE outputs variables to the screen or to a file or 
      device specified by device-number. Commas are inserted between expressions 
      output, and strings are enclosed in quotation marks. </TD>
    <TD vAlign=top>COMMON_CMDS </TD></TR></TBODY></TABLE>
<P>&nbsp;</P>
<DIV align=center>
<CENTER>
<TABLE border=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#800000>
      <P align=center><A href="http://www.bwbasic.com/home.html" 
      target=main><FONT color=#ffffff><STRONG>Return to Bywater BASIC Home 
      Page</STRONG></FONT></A></P></TD></TR></TBODY></TABLE></CENTER></DIV></BODY></HTML>
